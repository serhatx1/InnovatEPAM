# Research: Draft Idea Submissions

**Feature**: 3-draft-submissions
**Created**: 2026-02-26

## R1: Adding "draft" Status to Existing Schema

**Task**: How to add a "draft" value to the existing `idea.status` CHECK constraint and handle the `deleted_at` column.

**Decision**: Create a new migration (`005_add_draft_support.sql`) that drops and recreates the CHECK constraint to include "draft", and adds a `deleted_at TIMESTAMPTZ` column with DEFAULT NULL.

**Rationale**: PostgreSQL does not support `ALTER CONSTRAINT` to add values to a CHECK constraint. The standard approach is `ALTER TABLE DROP CONSTRAINT ... ADD CONSTRAINT ...` in a single migration. This is safe because the existing CHECK constraint name is auto-generated by the inline `CHECK (status IN (...))` syntax in 001. We use `ALTER TABLE idea DROP CONSTRAINT idea_status_check` (PostgreSQL auto-names inline checks as `{table}_{column}_check`). Adding `deleted_at` as a nullable TIMESTAMPTZ follows the soft-delete pattern — NULL means active, a timestamp means deleted.

**Alternatives considered**:
- **New table for drafts**: Rejected — drafts are the same entity as ideas (same fields, same attachments), just in a different lifecycle state. A separate table would duplicate schema and require joining/migrating data on submit.
- **ENUM type instead of CHECK**: Rejected — existing schema uses TEXT with CHECK, and Supabase doesn't natively support adding values to enums without `ALTER TYPE ... ADD VALUE` which can't run inside a transaction. CHECK constraint approach is consistent with the existing pattern.
- **Boolean `is_draft` column**: Rejected — the status field already models lifecycle states; adding "draft" as a status value is semantically correct and keeps the state machine in one field.

---

## R2: RLS Policy Changes for Draft Visibility

**Task**: How to modify existing RLS policies so drafts are invisible to non-owners while keeping existing idea visibility intact.

**Decision**: Modify the existing "Authenticated users can read all ideas" SELECT policy to exclude drafts (`status != 'draft'`). Add three new draft-specific policies: owner-only SELECT, owner-only UPDATE, and owner-only soft-DELETE for draft rows.

**Rationale**: The spec (FR-12, FR-13, FR-14) requires that drafts are invisible in the public listing and admin dashboard, enforced at the database level. Modifying the existing SELECT policy is the minimal change — it preserves all current behavior for non-draft ideas while filtering out drafts. The new owner-only policies use `(SELECT auth.uid()) = user_id` (cached uid pattern from existing schema) combined with `status = 'draft' AND deleted_at IS NULL` to restrict all draft operations to the owner.

**Policy design**:
| Policy | Operation | Condition |
|--------|-----------|-----------|
| Existing (modified) | SELECT | `auth.role() = 'authenticated' AND status != 'draft'` |
| Draft owner read | SELECT | `auth.uid() = user_id AND status = 'draft' AND deleted_at IS NULL` |
| Draft owner update | UPDATE | `auth.uid() = user_id AND status = 'draft' AND deleted_at IS NULL` |
| Draft owner delete | UPDATE | `auth.uid() = user_id AND status = 'draft'` (allows setting deleted_at) |
| Existing insert (modified) | INSERT | `auth.uid() = user_id` (allows both 'submitted' and 'draft' status) |

**Alternatives considered**:
- **Application-level filtering only**: Rejected — spec explicitly requires database-level RLS enforcement (FR-14).
- **Separate drafts table with its own RLS**: Rejected — over-engineered; same entity, just different visibility rules by status.

---

## R3: Soft-Delete Implementation

**Task**: How to implement soft-delete for drafts (FR-06) including query filtering and data retention.

**Decision**: Add `deleted_at TIMESTAMPTZ DEFAULT NULL` to the `idea` table. Soft-deleted drafts have `deleted_at` set to `now()`. All draft queries filter on `deleted_at IS NULL`. Attachment files remain in storage. RLS policies on draft rows include `deleted_at IS NULL` in their USING clause to make soft-deleted drafts invisible even to the owner.

**Rationale**: Soft delete preserves data for potential recovery while making the draft invisible in all user-facing queries. Using `TIMESTAMPTZ` (not a boolean) records when deletion occurred, which is useful for future cleanup jobs. The RLS-level enforcement means no application code can accidentally return soft-deleted drafts.

**Query pattern**:
```sql
-- All draft queries include:
WHERE status = 'draft' AND deleted_at IS NULL
```

**Alternatives considered**:
- **Hard delete**: Rejected — spec explicitly requires soft delete with `deleted_at` timestamp (FR-06).
- **Separate `is_deleted` boolean**: Rejected — timestamp provides more information (when deleted) at no extra cost.
- **Archive table**: Rejected — over-engineered for the use case; adds complexity without benefit.

---

## R4: Auto-Save Debounce Strategy

**Task**: How to implement auto-save with 3-second debounce (FR-16), dirty checking (FR-19), and status indication (FR-17).

**Decision**: Create a custom `useAutoSave` React hook that tracks form state, performs deep equality comparison against the last-saved snapshot, and debounces save calls by 3 seconds. On first auto-save of a new form, POST to create the draft; subsequent saves PATCH the existing draft.

**Rationale**: A custom hook encapsulates all auto-save logic (debounce, dirty check, save status, error handling) in a testable, reusable unit. The 3-second debounce balances between saving too frequently (wasting API calls) and saving too infrequently (risk of data loss). Deep equality comparison prevents unnecessary saves when the user clicks in a field but doesn't change content.

**Implementation approach**:
1. Hook accepts: `formData`, `draftId` (null for new), `stagingSessionId`, callbacks
2. On mount: snapshot initial form data as "last saved"
3. On formData change: start 3s debounce timer
4. On debounce fire: compare current vs last-saved (deep equality)
5. If different: set status "saving", call POST (new) or PATCH (existing), update snapshot, set status "saved"
6. If same: skip save (FR-19)
7. On error: set status "error", do NOT update snapshot (retry on next change)
8. Cleanup: cancel debounce timer on unmount

**Status states**: `"idle" | "saving" | "saved" | "error"`

**Alternatives considered**:
- **setInterval polling**: Rejected — wastes API calls when no changes. Debounce is more efficient.
- **localStorage fallback**: Rejected — out of scope per spec. Server-side persistence only.
- **Third-party auto-save library**: Rejected — simple enough to implement with a hook; avoids dependency bloat (Simplicity First).

---

## R5: Temporary Staging for Pre-Draft File Uploads

**Task**: How to handle file uploads when no draft record exists yet (Clarification Q2).

**Decision**: Upload files to a `staging/{sessionId}/{timestamp}-{filename}` path in Supabase Storage. When the draft is created (manually or via auto-save), move staged files to the permanent `{userId}/{timestamp}-{filename}` path and create `idea_attachment` records.

**Rationale**: The spec requires that uploads happen immediately even before a draft exists. A staging area separates uncommitted uploads from permanent storage. Using a client-generated session ID (UUID) ensures isolation between concurrent sessions. The move operation (copy + delete in Supabase Storage, since there's no native move) ensures files end up in the same path structure as normal uploads.

**Implementation approach**:
1. On form mount: generate a UUID `stagingSessionId`
2. When user adds files: upload to `staging/{sessionId}/{timestamp}-{filename}`
3. When draft is created (auto-save or manual save):
   - Call `moveStagedFiles(sessionId, ideaId)` which copies files to permanent path and deletes staging copies
   - Create `idea_attachment` records with the permanent paths
4. Orphan cleanup: admin endpoint or periodic job deletes staged files older than 24 hours

**Alternatives considered**:
- **Client-side only (no upload until draft exists)**: Rejected — spec says "Upload files immediately to a temporary staging area" (Clarification Q2).
- **Create draft record immediately on file upload**: Rejected — creates empty draft records on every file selection, even if user cancels.
- **localStorage blob storage**: Rejected — limited by browser storage size (typically 5–10 MB), not suitable for 10 MB files.

---

## R6: Draft Validation Schema Design

**Task**: How to handle dual validation — relaxed for draft save, full for draft submit.

**Decision**: Create two Zod schemas in `src/lib/validation/draft.ts`: `draftSaveSchema` (all fields optional) for save operations, and `draftSubmitSchema` (reuses `ideaSchema` rules) for the submit transition. Category field validation only applies at submit time.

**Rationale**: The spec explicitly states that drafts can be saved with any combination of fields (FR-02), including none at all. Full validation (title 5–100, description 20–1000, category required) only applies when transitioning from draft to submitted (FR-05). Two schemas clearly separate the two validation contexts.

**Schema design**:
```typescript
// Save: everything optional, title allows empty
export const draftSaveSchema = z.object({
  title: z.string().max(100).optional().default(""),
  description: z.string().max(1000).optional().default(""),
  category: z.string().optional().default(""),
  category_fields: z.record(z.unknown()).optional().default({}),
});

// Submit: reuses full ideaSchema rules
export const draftSubmitSchema = ideaSchema;
// Plus category_fields validation via validateCategoryFieldsForCategory()
```

**Alternatives considered**:
- **Single schema with conditional validation**: Rejected — harder to test and reason about; two separate schemas are clearer.
- **No validation on save**: Rejected — max-length constraints should still apply to prevent DB overflows on save.

---

## R7: Form Refactoring Strategy

**Task**: How to share form logic between the new idea page and the draft edit page.

**Decision**: Extract a shared `IdeaForm` component from the existing `NewIdeaPage` that accepts mode ("new" | "draft-edit"), initial data, draft ID, and callbacks. Both `/ideas/new` and `/ideas/drafts/[id]` pages use this component.

**Rationale**: The draft edit form has identical fields to the idea submission form — title, description, category, category fields, and file attachments. Duplicating the entire form would violate DRY and create maintenance burden. A shared component with mode-specific behavior (draft buttons, auto-save, pre-populated data) is the standard React pattern.

**Component interface**:
```typescript
interface IdeaFormProps {
  mode: "new" | "draft-edit";
  initialData?: Partial<Idea>;
  initialAttachments?: AttachmentResponse[];
  draftId?: string;
  stagingSessionId: string;
  onSaveDraft: (data: DraftSaveInput) => Promise<{ id: string }>;
  onSubmit: (data: IdeaInput) => Promise<void>;
}
```

**Alternatives considered**:
- **Duplicate form**: Rejected — violates DRY; changes to form fields would need to be made in two places.
- **Render props or HOC**: Rejected — a single component with props-based branching is simpler and more maintainable.
